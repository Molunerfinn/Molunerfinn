<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="Vite 原理浅析"><meta name="keywords" content="前端,Vue,Vite"><meta name="author" content="Molunerfinn"><meta name="copyright" content="Molunerfinn"><title>Vite 原理浅析 | MARKSZのBlog</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.5.2/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="manifest" href="/manifest.json"><link rel="manifest" href="/manifest.json"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle=window.adsbygoogle||[]).push({google_ad_client:"ca-pub-2358465699478507",enable_page_level_ads:"true"})</script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?19a7ebdbb87f2403773c7ab0cae16d21";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>!function(e,a,t,n,g,c,o){e.GoogleAnalyticsObject=g,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,c=a.createElement(t),o=a.getElementsByTagName(t)[0],c.async=1,c.src="https://www.google-analytics.com/analytics.js",o.parentNode.insertBefore(c,o)}(window,document,"script",0,"ga"),ga("create","UA-105869658-1","auto"),ga("send","pageview")</script><script>var GLOBAL_CONFIG={root:"/",algolia:{appId:"BGLU1ICJFH",apiKey:"85948beeaf121424b806828adc21c8b5",indexName:"mofinn",hits:{per_page:10},languages:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}.",hits_stats:"${hits} results found in ${time} ms"}},localSearch:void 0,copy:{success:"Copy successfully",error:"Copy error",noSupport:"The browser does not support"}}</script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是-Vite"><span class="toc-number">1.</span> <span class="toc-text">什么是 Vite</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#modules-模块"><span class="toc-number">1.1.</span> <span class="toc-text">modules 模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#编译和打包的区别"><span class="toc-number">1.2.</span> <span class="toc-text">编译和打包的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vite-运行-Web-应用的实现"><span class="toc-number">2.</span> <span class="toc-text">Vite 运行 Web 应用的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#拦截-HTTP-请求"><span class="toc-number">2.1.</span> <span class="toc-text">拦截 HTTP 请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#imports-替换"><span class="toc-number">2.2.</span> <span class="toc-text">imports 替换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#普通-JS-import-替换"><span class="toc-number">2.2.1.</span> <span class="toc-text">普通 JS import 替换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vue-文件的替换"><span class="toc-number">2.2.2.</span> <span class="toc-text">*.vue 文件的替换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#modules-路径解析"><span class="toc-number">3.</span> <span class="toc-text">@modules/* 路径解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vite-热更新的实现"><span class="toc-number">4.</span> <span class="toc-text">Vite 热更新的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#客户端"><span class="toc-number">4.1.</span> <span class="toc-text">客户端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#服务端"><span class="toc-number">4.2.</span> <span class="toc-text">服务端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#客户端逻辑的注入"><span class="toc-number">4.3.</span> <span class="toc-text">客户端逻辑的注入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结"><span class="toc-number">5.</span> <span class="toc-text">小结</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://blog-1251750343.cos.ap-beijing.myqcloud.com/blog/avatar.jpeg"></div><div class="author-info__name text-center">Molunerfinn</div><div class="author-info__description text-center">For MElody</div><div class="follow-button"><a href="https://github.com/Molunerfinn">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">76</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">25</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">24</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://molunerfinn.com">Molunerfinn</a><a class="author-info-links__name text-center" href="https://elody-07.github.io">Elody</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image:url(https://blog-1251750343.cos.ap-beijing.myqcloud.com/blog/blog-bg.jpg)"><div id="page-header"><span class="pull-left"><a id="site-name" href="/">MARKSZのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"> <a class="site-page" href="/about">About</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">Vite 原理浅析</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-03</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Web/">Web</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Web/开发/">开发</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">4.7k</span><span class="post-meta__separator">|</span><span>Reading time: 18 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>已经好久没有写博客了。本文不说 Vue3.0 了，相信已经有很多文章在说它了。而前一段时间尤大开源的 <a href="https://github.com/vuejs/vite" target="_blank" rel="noopener">Vite</a> 则是一个更加吸引我的东西，它的总体思路是很不错的，早期源码的学习成本也比较低，于是就趁着假期学习一番。</p><p>本文撰写于 Vite-0.9.1 版本。</p><a id="more"></a><h2 id="什么是-Vite"><a href="#什么是-Vite" class="headerlink" title="什么是 Vite"></a>什么是 Vite</h2><p>借用作者的原话：</p><blockquote><p>Vite，一个基于浏览器原生 ES imports 的开发服务器。利用浏览器去解析 imports，在服务器端按需编译返回，完全跳过了打包这个概念，服务器随起随用。同时不仅有 Vue 文件支持，还搞定了热更新，而且热更新的速度不会随着模块增多而变慢。针对生产环境则可以把同一份代码用 rollup 打包。虽然现在还比较粗糙，但这个方向我觉得是有潜力的，做得好可以彻底解决改一行代码等半天热更新的问题。</p></blockquote><p>注意到两个点：</p><ul><li>一个是 Vite 主要对应的场景是开发模式，原理是拦截浏览器发出的 ES imports 请求并做相应处理。（生产模式是用 rollup 打包）</li><li>一个是 Vite 在开发模式下不需要打包，只需要编译浏览器发出的 HTTP 请求对应的文件即可，所以热更新速度很快。</li></ul><p>因此，要实现上述目标，需要要求项目里只使用原生 ES imports，如果使用了 require 将失效，所以要用它完全替代掉 Webpack 就目前来说还是不太现实的。上面也说了，生产模式下的打包不是 Vite 自身提供的，因此生产模式下如果你想要用 Webpack 打包也依然是可以的。从这个角度来说，Vite 可能更像是替代了 webpack-dev-server 的一个东西。</p><h3 id="modules-模块"><a href="#modules-模块" class="headerlink" title="modules 模块"></a>modules 模块</h3><p>Vite 的实现离不开现代浏览器原生支持的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules" target="_blank" rel="noopener">模块功能</a>。如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; a &#125; <span class="keyword">from</span> <span class="string">'./a.js'</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当声明一个 <code>script</code> 标签类型为 <code>module</code> 时，浏览器将对其内部的 <code>import</code> 引用发起 <code>HTTP</code> 请求获取模块内容。比如上述，浏览器将发起一个对 <code>HOST/a.js</code> 的 HTTP 请求，获取到内容之后再执行。</p><p>Vite 劫持了这些请求，并在后端进行相应的处理（比如将 Vue 文件拆分成 <code>template</code>、<code>style</code>、<code>script</code> 三个部分），然后再返回给浏览器。</p><p>由于浏览器只会对用到的模块发起 HTTP 请求，所以 Vite 没必要对项目里所有的文件先打包后返回，而是只编译浏览器发起 HTTP 请求的模块即可。这里是不是有点按需加载的味道？</p><h3 id="编译和打包的区别"><a href="#编译和打包的区别" class="headerlink" title="编译和打包的区别"></a>编译和打包的区别</h3><p>看到这里，可能有些朋友不免有些疑问，编译和打包有什么区别？为什么 Vite 号称「热更新的速度不会随着模块增多而变慢」？</p><p>简单举个例子，有三个文件 <code>a.js</code>、<code>b.js</code>、<code>c.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="function"><span class="params">()</span> =&gt;</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">export</span> &#123; a &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="function"><span class="params">()</span> =&gt;</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">export</span> &#123; b &#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; a &#125; <span class="keyword">from</span> <span class="string">'./a'</span></span><br><span class="line"><span class="keyword">import</span> &#123; b &#125; <span class="keyword">from</span> <span class="string">'./b'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a() + b()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; c &#125;</span><br></pre></td></tr></table></figure><p>如果以 c 文件为入口，那么打包就会变成如下（结果进行了简化处理）：（假定打包文件名为 <code>bundle.js</code>)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bundle.js</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="function"><span class="params">()</span> =&gt;</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">const</span> b = <span class="function"><span class="params">()</span> =&gt;</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">const</span> c = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a() + b()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; c &#125;</span><br></pre></td></tr></table></figure><p><strong>值得注意的是，打包也需要有编译的步骤。</strong></p><p>Webpack 的热更新原理简单来说就是，一旦发生某个依赖（比如上面的 <code>a.js</code> ）改变，就将这个依赖所处的 <code>module</code> 的更新，并将新的 <code>module</code> 发送给浏览器重新执行。由于我们只打了一个 <code>bundle.js</code>，所以热更新的话也会重新打这个 <code>bundle.js</code>。试想如果依赖越来越多，就算只修改一个文件，理论上热更新的速度也会越来越慢。</p><p>而如果是像 Vite 这种只编译不打包会是什么情况呢？</p><p>只是编译的话，最终产出的依然是 <code>a.js</code>、<code>b.js</code>、<code>c.js</code> 三个文件，只有编译耗时。由于入口是 <code>c.js</code>，浏览器解析到 <code>import { a } from &#39;./a&#39;</code> 时，会发起 HTTP 请求 <code>a.js</code> （b 同理），就算不用打包，也可以加载到所需要的代码，因此省去了合并代码的时间。</p><p>在热更新的时候，如果 <code>a</code> 发生了改变，只需要更新 <code>a</code> 以及用到 <code>a</code> 的 <code>c</code>。由于 <code>b</code> 没有发生改变，所以 Vite 无需重新编译 <code>b</code>，可以从缓存中直接拿编译的结果。这样一来，修改一个文件 <code>a</code>，只会重新编译这个文件 <code>a</code> 以及浏览器当前用到这个文件 <code>a</code> 的文件，而其余文件都无需重新编译。所以理论上热更新的速度不会随着文件增加而变慢。</p><p>当然这样做有没有不好的地方？有，初始化的时候如果浏览器请求的模块过多，也会带来初始化的性能问题。不过如果你能遇到初始化过慢的这个问题，相信热更新的速度会弥补很多。当然我相信以后尤大也会解决这个问题。</p><h2 id="Vite-运行-Web-应用的实现"><a href="#Vite-运行-Web-应用的实现" class="headerlink" title="Vite 运行 Web 应用的实现"></a>Vite 运行 Web 应用的实现</h2><p>上面说了这么多的铺垫，可能还不够直观，我们可以先跑一个 Vite 项目来实际看看。</p><p>按照官网的说明，可以输入如下命令（<code>&lt;project-name&gt;</code> 为自己想要的目录名即可）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ npx create-vite-app &lt;project-name&gt;</span><br><span class="line">$ <span class="built_in">cd</span> &lt;project-name&gt;</span><br><span class="line">$ npm install</span><br><span class="line">$ npm run dev</span><br></pre></td></tr></table></figure><p>如果一切都正常你将在 <code>localhost:3000</code>（Vite 的服务器起的端口） 看到这个界面：</p><p><img src="https://cdn.jsdelivr.net/gh/Molunerfinn/test/blog/20200503152836.png" alt></p><p>并得到如下的代码结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── App.vue // 页面的主要逻辑</span><br><span class="line">├── index.html // 默认打开的页面以及 Vue 组件挂载</span><br><span class="line">├── node_modules</span><br><span class="line">└── package.json</span><br></pre></td></tr></table></figure><h3 id="拦截-HTTP-请求"><a href="#拦截-HTTP-请求" class="headerlink" title="拦截 HTTP 请求"></a>拦截 HTTP 请求</h3><p>接下来开始说一下 Vite 实现的核心——拦截浏览器对模块的请求并返回处理后的结果。</p><p>我们知道，由于是在 <code>localhost:3000</code> 打开的网页，所以浏览器发起的第一个请求自然是请求 <code>localhost:3000/</code>，这个请求发送到 Vite 后端之后经过静态资源服务器的处理，会进而请求到 <code>/index.html</code>，此时 Vite 就开始对这个请求做拦截和处理了。</p><p>首先，<code>index.html</code> 里的源码是这样的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">createApp(App).mount(<span class="string">'#app'</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是在浏览器里它是这样的：</p><p><img src="https://cdn.jsdelivr.net/gh/Molunerfinn/test/blog/20200503153404.png" alt></p><p>注意到什么不同了吗？是的， <code>import { createApp } from &#39;vue&#39;</code> 换成了 <code>import { createApp } from &#39;/@modules/vue</code>。</p><p>这里就不得不说浏览器对 <code>import</code> 的模块发起请求时的一些局限了，平时我们写代码，如果不是引用相对路径的模块，而是引用 <code>node_modules</code> 的模块，都是直接 <code>import xxx from &#39;xxx&#39;</code>，由 Webpack 等工具来帮我们找这个模块的具体路径。但是浏览器不知道你项目里有 <code>node_modules</code>，它只能通过相对路径去寻找模块。</p><p>因此 Vite 在拦截的请求里，对直接引用 <code>node_modules</code> 的模块都做了路径的替换，换成了 <code>/@modules/</code> 并返回回去。而后浏览器收到后，会发起对 <code>/@modules/xxx</code> 的请求，然后被 Vite 再次拦截，并由 Vite 内部去访问真正的模块，并将得到的内容再次做同样的处理后，返回给浏览器。</p><h3 id="imports-替换"><a href="#imports-替换" class="headerlink" title="imports 替换"></a>imports 替换</h3><h4 id="普通-JS-import-替换"><a href="#普通-JS-import-替换" class="headerlink" title="普通 JS import 替换"></a>普通 JS import 替换</h4><p>上面说的这步替换来自 <code>src/node/serverPluginModuleRewrite.ts</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只取关键代码：</span></span><br><span class="line"><span class="comment">// Vite 使用 Koa 作为内置的服务器</span></span><br><span class="line"><span class="comment">// 如果请求的路径是 /index.html</span></span><br><span class="line"><span class="keyword">if</span> (ctx.path === <span class="string">'/index.html'</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">const</span> html = <span class="keyword">await</span> readBody(ctx.body)</span><br><span class="line">  ctx.body = html.replace(</span><br><span class="line">    /(<span class="xml"><span class="tag">&lt;<span class="name">script\b[^</span>&gt;</span>]*&gt;)([\s\S]*?)<span class="tag">&lt;<span class="name">\</span>/<span class="attr">script</span>&gt;</span>/gm, // 正则匹配</span></span><br><span class="line"><span class="xml">    (_, openTag, script) =&gt; &#123;</span></span><br><span class="line"><span class="xml">      // also inject __DEV__ flag</span></span><br><span class="line"><span class="xml">      const devFlag = hasInjectedDevFlag ? `` : devInjectionCode</span></span><br><span class="line"><span class="xml">      hasInjectedDevFlag = true</span></span><br><span class="line"><span class="xml">       // 替换 html 的 import 路径</span></span><br><span class="line"><span class="xml">      return `$&#123;devFlag&#125;$&#123;openTag&#125;$&#123;rewriteImports(</span></span><br><span class="line"><span class="xml">        script,</span></span><br><span class="line"><span class="xml">        '/index.html',</span></span><br><span class="line"><span class="xml">        resolver</span></span><br><span class="line"><span class="xml">      )&#125;<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><span class="string">`</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  )</span></span><br><span class="line"><span class="string">  // ...</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>如果并没有在 <code>script</code> 标签内部直接写 <code>import</code>，而是用 <code>src</code> 的形式引用的话如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"module"</span> src=<span class="string">"/main.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>那么就会在浏览器发起对 <code>main.js</code> 请求的时候进行处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只取关键代码：</span></span><br><span class="line"><span class="keyword">if</span> (</span><br><span class="line">  ctx.response.is(<span class="string">'js'</span>) &amp;&amp;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">const</span> content = <span class="keyword">await</span> readBody(ctx.body)</span><br><span class="line">  <span class="keyword">await</span> initLexer</span><br><span class="line">  <span class="comment">// 重写 js 文件里的 import</span></span><br><span class="line">  ctx.body = rewriteImports(</span><br><span class="line">    content,</span><br><span class="line">    ctx.url.replace(<span class="regexp">/(&amp;|\?)t=\d+/</span>, <span class="string">''</span>),</span><br><span class="line">    resolver,</span><br><span class="line">    ctx.query.t</span><br><span class="line">  )</span><br><span class="line">  <span class="comment">// 写入缓存，之后可以从缓存中直接读取</span></span><br><span class="line">  rewriteCache.set(content, ctx.body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>替换逻辑 <code>rewriteImports</code> 就不展开了，用的是 <code>es-module-lexer</code> 来进行的语法分析获取 <code>imports</code> 数组，然后再做的替换。</p><h4 id="vue-文件的替换"><a href="#vue-文件的替换" class="headerlink" title="*.vue 文件的替换"></a>*.vue 文件的替换</h4><p>如果 <code>import</code> 的是 <code>.vue</code> 文件，将会做更进一步的替换：</p><p>原本的 <code>App.vue</code> 文件长这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello Vite + Vue 3!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Edit ./App.vue to test hot module replacement (HMR).<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>Count is: &#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"count++"</span>&gt;</span>increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  data: <span class="function"><span class="params">()</span> =&gt;</span> (&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;),</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line">h1 &#123;</span><br><span class="line"><span class="css">  <span class="selector-tag">color</span>: <span class="selector-id">#4fc08d</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h1, p &#123;</span><br><span class="line">  font-family: Arial, Helvetica, sans-serif;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>替换后长这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// localhost:3000/App.vue</span></span><br><span class="line"><span class="keyword">import</span> &#123; updateStyle &#125; <span class="keyword">from</span> <span class="string">"/@hmr"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽出 script 逻辑</span></span><br><span class="line"><span class="keyword">const</span> __script = &#123;</span><br><span class="line">  data: <span class="function"><span class="params">()</span> =&gt;</span> (&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 style 拆分成 /App.vue?type=style 请求，由浏览器继续发起请求获取样式</span></span><br><span class="line">updateStyle(<span class="string">"c44b8200-0"</span>, <span class="string">"/App.vue?type=style&amp;index=0&amp;t=1588490870523"</span>)</span><br><span class="line">__script.__scopeId = <span class="string">"data-v-c44b8200"</span> <span class="comment">// 样式的 scopeId</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 template 拆分成 /App.vue?type=template 请求，由浏览器继续发起请求获取 render function</span></span><br><span class="line"><span class="keyword">import</span> &#123; render <span class="keyword">as</span> __render &#125; <span class="keyword">from</span> <span class="string">"/App.vue?type=template&amp;t=1588490870523&amp;t=1588490870523"</span></span><br><span class="line">__script.render = __render <span class="comment">// render 方法挂载，用于 createApp 时渲染</span></span><br><span class="line">__script.__hmrId = <span class="string">"/App.vue"</span> <span class="comment">// 记录 HMR 的 id，用于热更新</span></span><br><span class="line">__script.__file = <span class="string">"/XXX/web/vite-test/App.vue"</span> <span class="comment">// 记录文件的原始的路径，后续热更新能用到</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> __script</span><br></pre></td></tr></table></figure><p>这样就把原本一个 <code>.vue</code> 的文件拆成了三个请求（分别对应 <code>script</code>、<code>style</code> 和<code>template</code>） ，浏览器会先收到包含 <code>script</code> 逻辑的 <code>App.vue</code> 的响应，然后解析到 <code>template</code> 和 <code>style</code> 的路径后，会再次发起 HTTP 请求来请求对应的资源，此时 Vite 对其拦截并再次处理后返回相应的内容。</p><p>如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Molunerfinn/test/blog/20200503171228.png" alt></p><p>不得不说这个思路是非常巧妙的。</p><p>这一步的拆分来自 <code>src/node/serverPluginVue.ts</code>，核心逻辑是根据 URL 的 query 参数来做不同的处理（简化分析如下）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果没有 query 的 type，比如直接请求的 /App.vue</span></span><br><span class="line"><span class="keyword">if</span> (!query.type) &#123;</span><br><span class="line">  ctx.type = <span class="string">'js'</span></span><br><span class="line">  ctx.body = compileSFCMain(descriptor, filePath, publicPath) <span class="comment">// 编译 App.vue，编译成上面说的带有 script 内容，以及 template 和 style 链接的形式。</span></span><br><span class="line">  <span class="keyword">return</span> etagCacheCheck(ctx) <span class="comment">// ETAG 缓存检测相关逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 query 的 type 是 template，比如 /App.vue?type=template&amp;xxx</span></span><br><span class="line"><span class="keyword">if</span> (query.type === <span class="string">'template'</span>) &#123;</span><br><span class="line">  ctx.type = <span class="string">'js'</span></span><br><span class="line">  ctx.body = compileSFCTemplate( <span class="comment">// 编译 template 生成 render function</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">return</span> etagCacheCheck(ctx)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 query 的 type 是 style，比如 /App.vue?type=style&amp;xxx</span></span><br><span class="line"><span class="keyword">if</span> (query.type === <span class="string">'style'</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> index = <span class="built_in">Number</span>(query.index)</span><br><span class="line">  <span class="keyword">const</span> styleBlock = descriptor.styles[index]</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> compileSFCStyle( <span class="comment">// 编译 style</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">if</span> (query.module != <span class="literal">null</span>) &#123; <span class="comment">// 如果是 css module</span></span><br><span class="line">    ctx.type = <span class="string">'js'</span></span><br><span class="line">    ctx.body = <span class="string">`export default <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(result.modules)&#125;</span>`</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 正常 css</span></span><br><span class="line">    ctx.type = <span class="string">'css'</span></span><br><span class="line">    ctx.body = result.code</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="modules-路径解析"><a href="#modules-路径解析" class="headerlink" title="@modules/* 路径解析"></a>@modules/* 路径解析</h2><p>上面只涉及到了替换的逻辑，解析的逻辑来自 <code>src/node/serverPluginModuleResolve.ts</code>。这一步就相对简单了，核心逻辑就是去 <code>node_modules</code> 里找有没有对应的模块，有的话就返回，没有的话就报 404：（省略了很多逻辑，比如对 <code>web_modules</code> 的处理、缓存的处理等）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> file = resolve(root, id) <span class="comment">// id 是模块的名字，比如 axios</span></span><br><span class="line">  <span class="keyword">return</span> serve(id, file, <span class="string">'node_modules'</span>) <span class="comment">// 从 node_modules 中找到真正的模块内容并返回</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(</span><br><span class="line">    chalk.red(<span class="string">`[vite] Error while resolving node_modules with id "<span class="subst">$&#123;id&#125;</span>":`</span>)</span><br><span class="line">  )</span><br><span class="line">  <span class="built_in">console</span>.error(e)</span><br><span class="line">  ctx.status = <span class="number">404</span> <span class="comment">// 如果没找到就 404</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Vite-热更新的实现"><a href="#Vite-热更新的实现" class="headerlink" title="Vite 热更新的实现"></a>Vite 热更新的实现</h2><p>上面已经说完了 Vite 是如何运行一个 Web 应用的，包括如何拦截请求、替换内容、返回处理后的结果。接下来说一下 Vite 热更新的实现，同样实现的非常巧妙。</p><p>我们知道，如果要实现热更新，那么就需要浏览器和服务器建立某种通信机制，这样浏览器才能收到通知进行热更新。Vite 的是通过 <code>WebSocket</code> 来实现的热更新通信。</p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>客户端的代码在 <code>src/client/client.ts</code>，主要是创建 <code>WebSocket</code> 客户端，监听来自服务端的 HMR 消息推送。</p><p>Vite 的 WS 客户端目前监听这几种消息：</p><ul><li><code>connected</code>: WebSocket 连接成功</li><li><code>vue-reload</code>: Vue 组件重新加载（当你修改了 script 里的内容时）</li><li><code>vue-rerender</code>: Vue 组件重新渲染（当你修改了 template 里的内容时）</li><li><code>style-update</code>: 样式更新</li><li><code>style-remove</code>: 样式移除</li><li><code>js-update</code>: js 文件更新</li><li><code>full-reload</code>: fallback 机制，网页重刷新</li></ul><p>其中针对 Vue 组件本身的一些更新，都可以直接调用 <code>HMRRuntime</code> 提供的方法，非常方便。其余的更新逻辑，基本上都是利用了 <code>timestamp</code> 刷新缓存重新执行的方法来达到更新的目的。</p><p>核心逻辑如下，我感觉非常清晰明了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; HMRRuntime &#125; <span class="keyword">from</span> <span class="string">'vue'</span> <span class="comment">// 来自 Vue3.0 的 HMRRuntime</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'[vite] connecting...'</span>)</span><br><span class="line"></span><br><span class="line">declare <span class="keyword">var</span> __VUE_HMR_RUNTIME__: HMRRuntime</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">`ws://<span class="subst">$&#123;location.host&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Listen for messages</span></span><br><span class="line">socket.addEventListener(<span class="string">'message'</span>, (&#123; data &#125;) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; type, path, id, index, timestamp, customData &#125; = <span class="built_in">JSON</span>.parse(data)</span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'connected'</span>:</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`[vite] connected.`</span>)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'vue-reload'</span>:</span><br><span class="line">      <span class="keyword">import</span>(<span class="string">`<span class="subst">$&#123;path&#125;</span>?t=<span class="subst">$&#123;timestamp&#125;</span>`</span>).then(<span class="function">(<span class="params">m</span>) =&gt;</span> &#123;</span><br><span class="line">        __VUE_HMR_RUNTIME__.reload(path, m.default)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`[vite] <span class="subst">$&#123;path&#125;</span> reloaded.`</span>) <span class="comment">// 调用 HMRRUNTIME 的方法更新</span></span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'vue-rerender'</span>:</span><br><span class="line">      <span class="keyword">import</span>(<span class="string">`<span class="subst">$&#123;path&#125;</span>?type=template&amp;t=<span class="subst">$&#123;timestamp&#125;</span>`</span>).then(<span class="function">(<span class="params">m</span>) =&gt;</span> &#123;</span><br><span class="line">        __VUE_HMR_RUNTIME__.rerender(path, m.render)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`[vite] <span class="subst">$&#123;path&#125;</span> template updated.`</span>) <span class="comment">// 调用 HMRRUNTIME 的方法更新</span></span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'style-update'</span>:</span><br><span class="line">      updateStyle(id, <span class="string">`<span class="subst">$&#123;path&#125;</span>?type=style&amp;index=<span class="subst">$&#123;index&#125;</span>&amp;t=<span class="subst">$&#123;timestamp&#125;</span>`</span>) <span class="comment">// 重新加载 style 的 URL</span></span><br><span class="line">      <span class="built_in">console</span>.log(</span><br><span class="line">        <span class="string">`[vite] <span class="subst">$&#123;path&#125;</span> style<span class="subst">$&#123;index &gt; <span class="number">0</span> ? <span class="string">`#<span class="subst">$&#123;index&#125;</span>`</span> : <span class="string">``</span>&#125;</span> updated.`</span></span><br><span class="line">      )</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'style-remove'</span>:</span><br><span class="line">      <span class="keyword">const</span> link = <span class="built_in">document</span>.getElementById(<span class="string">`vite-css-<span class="subst">$&#123;id&#125;</span>`</span>)</span><br><span class="line">      <span class="keyword">if</span> (link) &#123;</span><br><span class="line">        <span class="built_in">document</span>.head.removeChild(link) <span class="comment">// 删除 style</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'js-update'</span>:</span><br><span class="line">      <span class="keyword">const</span> update = jsUpdateMap.get(path)</span><br><span class="line">      <span class="keyword">if</span> (update) &#123;</span><br><span class="line">        update(timestamp) <span class="comment">// 用新的时间戳加载并执行 js，达到更新的目的</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`[vite]: js module reloaded: `</span>, path)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(</span><br><span class="line">          <span class="string">`[vite] got js update notification but no client callback was registered. Something is wrong.`</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'custom'</span>:</span><br><span class="line">      <span class="keyword">const</span> cbs = customUpdateMap.get(id)</span><br><span class="line">      <span class="keyword">if</span> (cbs) &#123;</span><br><span class="line">        cbs.forEach(<span class="function">(<span class="params">cb</span>) =&gt;</span> cb(customData))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'full-reload'</span>:</span><br><span class="line">      location.reload()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>服务端的实现位于 <code>src/node/serverPluginHmr.ts</code>。核心是监听项目文件的变更，然后根据不同文件类型（目前只有 <code>vue</code> 和 <code>js</code>）来做不同的处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">watcher.on(<span class="string">'change'</span>, <span class="keyword">async</span> (file) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> timestamp = <span class="built_in">Date</span>.now() <span class="comment">// 更新时间戳</span></span><br><span class="line">  <span class="keyword">if</span> (file.endsWith(<span class="string">'.vue'</span>)) &#123;</span><br><span class="line">    handleVueReload(file, timestamp)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (file.endsWith(<span class="string">'.js'</span>)) &#123;</span><br><span class="line">    handleJSReload(file, timestamp)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对于 <code>Vue</code> 文件的热更新而言，主要是重新编译 <code>Vue</code> 文件，检测 <code>template</code> 、<code>script</code> 、<code>style</code> 的改动，如果有改动就通过 WS 服务端发起对应的热更新请求。</p><p>简单的源码分析如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">handleVueReload</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    file: string,</span></span></span><br><span class="line"><span class="function"><span class="params">    timestamp: number = Date.now(</span>),</span></span><br><span class="line"><span class="function">    <span class="title">content</span>?: <span class="title">string</span></span></span><br><span class="line"><span class="function">) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> publicPath = resolver.fileToRequest(file) <span class="comment">// 获取文件的路径</span></span><br><span class="line">  <span class="keyword">const</span> cacheEntry = vueCache.get(file) <span class="comment">// 获取缓存里的内容</span></span><br><span class="line"></span><br><span class="line">  debugHmr(<span class="string">`busting Vue cache for <span class="subst">$&#123;file&#125;</span>`</span>)</span><br><span class="line">  vueCache.del(file) <span class="comment">// 发生变动了因此之前的缓存可以删除</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> descriptor = <span class="keyword">await</span> parseSFC(root, file, content) <span class="comment">// 编译 Vue 文件</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> prevDescriptor = cacheEntry &amp;&amp; cacheEntry.descriptor <span class="comment">// 获取前一次的缓存</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!prevDescriptor) &#123;</span><br><span class="line">    <span class="comment">// 这个文件之前从未被访问过（本次是第一次访问），也就没必要热更新</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置两个标志位，用于判断是需要 reload 还是 rerender</span></span><br><span class="line">  <span class="keyword">let</span> needReload = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">let</span> needRerender = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果 script 部分不同则需要 reload</span></span><br><span class="line">  <span class="keyword">if</span> (!isEqual(descriptor.script, prevDescriptor.script)) &#123;</span><br><span class="line">    needReload = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果 template 部分不同则需要 rerender</span></span><br><span class="line">  <span class="keyword">if</span> (!isEqual(descriptor.template, prevDescriptor.template)) &#123;</span><br><span class="line">    needRerender = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> styleId = hash_sum(publicPath)</span><br><span class="line">  <span class="comment">// 获取之前的 style 以及下一次（或者说热更新）的 style</span></span><br><span class="line">  <span class="keyword">const</span> prevStyles = prevDescriptor.styles || []</span><br><span class="line">  <span class="keyword">const</span> nextStyles = descriptor.styles || []</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果不需要 reload，则查看是否需要更新 style</span></span><br><span class="line">  <span class="keyword">if</span> (!needReload) &#123;</span><br><span class="line">    nextStyles.forEach(<span class="function">(<span class="params">_, i</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!prevStyles[i] || !isEqual(prevStyles[i], nextStyles[i])) &#123;</span><br><span class="line">        send(&#123;</span><br><span class="line">          type: <span class="string">'style-update'</span>,</span><br><span class="line">          path: publicPath,</span><br><span class="line">          index: i,</span><br><span class="line">          id: <span class="string">`<span class="subst">$&#123;styleId&#125;</span>-<span class="subst">$&#123;i&#125;</span>`</span>,</span><br><span class="line">          timestamp</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果 style 标签及内容删掉了，则需要发送 `style-remove` 的通知</span></span><br><span class="line">  prevStyles.slice(nextStyles.length).forEach(<span class="function">(<span class="params">_, i</span>) =&gt;</span> &#123;</span><br><span class="line">    send(&#123;</span><br><span class="line">      type: <span class="string">'style-remove'</span>,</span><br><span class="line">      path: publicPath,</span><br><span class="line">      id: <span class="string">`<span class="subst">$&#123;styleId&#125;</span>-<span class="subst">$&#123;i + nextStyles.length&#125;</span>`</span>,</span><br><span class="line">      timestamp</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果需要 reload 发送 `vue-reload` 通知</span></span><br><span class="line">  <span class="keyword">if</span> (needReload) &#123;</span><br><span class="line">    send(&#123;</span><br><span class="line">      type: <span class="string">'vue-reload'</span>,</span><br><span class="line">      path: publicPath,</span><br><span class="line">      timestamp</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (needRerender) &#123;</span><br><span class="line">    <span class="comment">// 否则发送 `vue-rerender` 通知</span></span><br><span class="line">    send(&#123;</span><br><span class="line">      type: <span class="string">'vue-rerender'</span>,</span><br><span class="line">      path: publicPath,</span><br><span class="line">      timestamp</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于热更新 <code>js</code> 文件而言，会递归地查找引用这个文件的 <code>importer</code>。比如是某个 <code>Vue</code> 文件所引用了这个 <code>js</code>，就会被查找出来。假如最终发现找不到引用者，则会返回 <code>hasDeadEnd: true</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vueImporters = <span class="keyword">new</span> <span class="built_in">Set</span>&lt;string&gt;() <span class="comment">// 查找并存放需要热更新的 Vue 文件</span></span><br><span class="line"><span class="keyword">const</span> jsHotImporters = <span class="keyword">new</span> <span class="built_in">Set</span>&lt;string&gt;() <span class="comment">// 查找并存放需要热更新的 js 文件</span></span><br><span class="line"><span class="keyword">const</span> hasDeadEnd = walkImportChain(</span><br><span class="line">  publicPath,</span><br><span class="line">  importers,</span><br><span class="line">  vueImporters,</span><br><span class="line">  jsHotImporters</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如果 <code>hasDeadEnd</code> 为 <code>true</code>，则直接发送 <code>full-reload</code>。如果 <code>vueImporters</code> 或 <code>jsHotImporters</code> 里查找到需要热更新的文件，则发起热更新通知：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (hasDeadEnd) &#123;</span><br><span class="line">  send(&#123;</span><br><span class="line">    type: <span class="string">'full-reload'</span>,</span><br><span class="line">    timestamp</span><br><span class="line">  &#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  vueImporters.forEach(<span class="function">(<span class="params">vueImporter</span>) =&gt;</span> &#123;</span><br><span class="line">    send(&#123;</span><br><span class="line">      type: <span class="string">'vue-reload'</span>,</span><br><span class="line">      path: vueImporter,</span><br><span class="line">      timestamp</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  jsHotImporters.forEach(<span class="function">(<span class="params">jsImporter</span>) =&gt;</span> &#123;</span><br><span class="line">    send(&#123;</span><br><span class="line">      type: <span class="string">'js-update'</span>,</span><br><span class="line">      path: jsImporter,</span><br><span class="line">      timestamp</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端逻辑的注入"><a href="#客户端逻辑的注入" class="headerlink" title="客户端逻辑的注入"></a>客户端逻辑的注入</h3><p>写到这里，还有一个问题是，我们在自己的代码里并没有引入 <code>HRM</code> 的 <code>client</code> 代码，Vite 是如何把 <code>client</code> 代码注入的呢？</p><p>回到上面的一张图，Vite 重写 <code>App.vue</code> 文件的内容并返回时：</p><p><img src="https://cdn.jsdelivr.net/gh/Molunerfinn/test/blog/20200503171228.png" alt></p><p>注意这张图里的代码区第一句话 <code>import { updateStyle } from &#39;/@hmr&#39;</code>，并且在左侧请求列表中也有一个对 <code>@hmr</code> 文件的请求。这个请求是啥呢？</p><p><img src="https://cdn.jsdelivr.net/gh/Molunerfinn/test/blog/20200503201312.png" alt></p><p>可以发现，这个请求就是上面说的客户端逻辑的 <code>client.ts</code> 的内容。</p><p>在 <code>src/node/serverPluginHmr.ts</code> 里，有针对 <code>@hmr</code> 文件的解析处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> hmrClientFilePath = path.resolve(__dirname, <span class="string">'./client.js'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> hmrClientId = <span class="string">'@hmr'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> hmrClientPublicPath = <span class="string">`/<span class="subst">$&#123;hmrClientId&#125;</span>`</span></span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (ctx.path !== hmrClientPublicPath) &#123; <span class="comment">// 请求路径如果不是 @hmr 就跳过</span></span><br><span class="line">    <span class="keyword">return</span> next()</span><br><span class="line">  &#125;</span><br><span class="line">  debugHmr(<span class="string">'serving hmr client'</span>)</span><br><span class="line">  ctx.type = <span class="string">'js'</span></span><br><span class="line">  <span class="keyword">await</span> cachedRead(ctx, hmrClientFilePath) <span class="comment">// 返回 client.js 的内容</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>至此，热更新的整体流程已经解析完毕。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这个项目最近在以惊人的速度迭代着，因此没过多久以后再回头看这篇文章，可能代码、实现已经过时。不过 Vite 的整体思路是非常棒的，在早期源码不多的情况下，能学到更贴近作者原始想法的东西，也算是很不错的收获。希望本文能给你学习 Vite 一些参考，有错误也欢迎大家指出。</p></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Molunerfinn</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://molunerfinn.com/learn-vite/">https://molunerfinn.com/learn-vite/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/前端/">前端</a><a class="post-meta__tags" href="/tags/Vue/">Vue</a><a class="post-meta__tags" href="/tags/Vite/">Vite</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://blog-1251750343.cos.ap-beijing.myqcloud.com/blog/alipay.jpg"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://blog-1251750343.cos.ap-beijing.myqcloud.com/blog/wechat-pay.jpg"><div class="post-qr-code__desc">微信打赏</div></div></div><div class="addthis_inline_share_toolbox pull-right"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5994f8f0fea9a5f4" async></script><nav id="pagination"><div class="next-post pull-right"><a href="/typora-supports-picgo/"><span>Typora 支持 PicGo 来上传图片了</span><i class="fa fa-chevron-right"></i></a></div></nav><div class="post-adv"><a href="https://lostcloud.club/auth/register?code=O58Z227227WresQi">~超快便宜好用的SSR机场点我注册~</a></div><div id="gitalk-container"></div><script>var gitalk=new Gitalk({clientID:"f7b6cca0b0a65f07a027",clientSecret:"7f2daa09738c589122bf2882ee8cdbc62607c4d8",repo:"Molunerfinn.github.io",owner:"Molunerfinn",admin:"Molunerfinn",id:md5(decodeURI(location.pathname)),language:"en"});gitalk.render("gitalk-container")</script></div></div><footer class="footer-bg" style="background-image:url(https://blog-1251750343.cos.ap-beijing.myqcloud.com/blog/blog-bg.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2015 - 2020 By Molunerfinn</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/algolia.js"></script><script>/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)&&($("#nav").addClass("is-mobile"),$("footer").addClass("is-mobile"),$("#top-container").addClass("is-mobile"))</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>